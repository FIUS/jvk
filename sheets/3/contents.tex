
\begin{center}
        \begin{tabular}{ l | c | c | l }
                Text & Math. Zeichen & Java & Bemerkung\\
            \hline
                  gr\"oßer als & $>$ & $>$ & \\
                  kleiner als & $<$ & $<$ & \\
                  gleich & $=$ & $==$ & einfaches $=$ ist in Java eine Zuweisung\\
                  ungleich & $\neq$ & $!=$ & \\
                  gr\"oßer gleich & $\geq$ & $>=$ & wie man es spricht \glqq größer gleich\grqq{} \\
                  kleiner gleich & $\leq$ & $<=$ &  \\
        \end{tabular} \\
        \vspace{1cm}
        \begin{tabular}{ l | l | l | l}
            Text & log. Zeichen & Java Zeichen &Bemerkung \\
            \hline
            und  &$\land$& $\&\&$& \minibox{Achtung kein einfaches \& in Java verwenden,\\ das macht etwas anderes (aber ähnliches)} \\
            oder  &$\lor$& $||$& Kein einfaches $|$ verwenden (analog zu und) \\
            & &  \\

            nicht & $!$&$\neg$ &\\
    \end{tabular}\\
\end{center}
\subsubsection*{Aufgabe 0: Vererbung}
Neo hat im Lotto gewonnen und hat jetzt viel Geld. Da er von Keanu Reevs gespielt wird und daher alle Menschen liebt bzw. sowieso schon zu viel Geld auf dem Konto hat, verschenkt er seinen Gewinn. Schreibe die Klasse RichNeo die Neo dirket mit 100000 Coins im Wallet erzeugt. Außerdem lässt RichNeo bei jedem Schritt 100 Coins auf dem Boden zurück.

\emph{Zusatz:} Lass RichNeo auf eine Wanderung gehen: RichNeo soll so lange laufen bis er nur noch die Hälfte seines Gelds hat.

\emph{Zusatz:} Weil wir im letzten Moment die Reihenfolge geändert haben ist die Nummer für diesen Taks 3.5.

Denke daran, in der Klasse \texttt{Task3\_5.java} die Klasse von Neo auf RichNeo zu ändern, sobald du die Klasse \texttt{RichNeo.java} erstellt hast.
\begin{questions}
    \renewcommand{\workingtimeMinutes}{30}
    \titledquestion{Logik}
        \begin{parts}
            \part Fülle die folgenden Tabellen aus:\\
            \begin{center}
            \begin{tabular}{ c | c }
            A & !A \\
            \hline
            true & \\
            false & \\
            \end{tabular}
            \quad
            \begin{tabular}{ c | c | c }
            A & B & A \&\& B \\
            \hline
            false & false & \\
            false & true & \\
            true & false & \\
            true & true & \\
            \end{tabular}
            \quad
            \begin{tabular}{ c | c | c }
            A & B & A $||$ B \\
            \hline
            false & false & \\
            false & true & \\
            true & false & \\
            true & true & \\
            \end{tabular}\\
            \end{center}
                \begin{solution}
                  \begin{center}
                      \begin{tabular}{ c | c }
            A & !A \\
            \hline
            true & false\\
            false & true\\
            \end{tabular}
            \quad
            \begin{tabular}{ c | c | c }
            A & B & A \&\& B \\
            \hline
            false & false & false\\
            false & true & false\\
            true & false & false\\
            true & true & true\\
            \end{tabular}
            \quad
            \begin{tabular}{ c | c | c }
            A & B & A $||$ B \\
            \hline
            false & false & false\\
            false & true & true\\
            true & false & true\\
            true & true & true\\
            \end{tabular}\\
                  \end{center}
                \end{solution}

            \part Schreibe zu jeder Aussage eine If-Anweisung, die den Wert von x überprüfen soll nach:
            \begin{enumerate}[label=(\roman*)]
                \item x = 12345
                \item x $\leq$ 15
                \item x $\neq$ 22
                \item x $\in [0; 10]$
                \item x $\in$ \{\texttt{Integer.MINVALUE}, ..., -2, -1, 11, 12, 13, ..., \texttt{Integer.MAXVALUE}\}\\(Alle Integer außer [0;10])
                \item x $\in$ \{x $|$ x ist gerade\}
            \end{enumerate}
            \emph{Anmerkung:} Mit dem Befehl \lstinline{Logger.simout.println("...");} könnt ihr Text in die Ausgabe des Simulators schreiben.
            \begin{solution}
            \begin{enumerate}[label=(\roman*)]
            \item \begin{lstlisting}
if(x == 12345){
    neo.print("erfüllt");
}
                   \end{lstlisting}

            \item \begin{lstlisting}
if(x <= 15){
    neo.print("erfüllt");
}
                   \end{lstlisting}

            \item \begin{lstlisting}
if(x != 22){
    neo.print("erfüllt");
}
                   \end{lstlisting}

            \item \begin{lstlisting}
if(0 < x && x < 10){
    neo.print("erfüllt");
}
                   \end{lstlisting}

\item \begin{lstlisting}
if(x < 0 || 10 < x){
    neo.print("erfüllt");
}
                   \end{lstlisting}

                   \item \begin{lstlisting}
if(x%2 == 0){
    neo.print("erfüllt");
}
                   \end{lstlisting}
            \end{enumerate}

                \end{solution}
        \end{parts}

    \renewcommand{\workingtimeMinutes}{30}
    \titledquestion{Schleifen}
        \begin{parts}
            \part Schreibe deine \texttt{turnLeft()} so um, dass sie eine for-Schleife verwendet.
            \begin{solution}
                   \begin{lstlisting}
for(int i = 0; i != 3; ++i){
    neo.turnClockWise();
}
                   \end{lstlisting}

                \end{solution}

            \part Neo muss so schnell wie möglich die nächstgelegene Telefonzelle erreichen, um die Matrix zu verlassen. Leider weiß er nicht genau, wie weit diese entfernt ist. Schreibe hierzu eine Operation, die Neo so lange geradeaus laufen lässt, bis die Operation \texttt{Neo.isOnPhoneBooth()} den Wert \texttt{true} zurück gibt. Verwende in deiner Lösung eine while-Schleife.
                \begin{solution}
                   \begin{lstlisting}
while(!neo.isOnPhoneBooth()) {
    neo.move();
}
                   \end{lstlisting}

                \end{solution}

            \part(\textbf{Bonus}) Schreibe die Operation aus \textit{(b)} so um, dass sie eine do-while-Schleife verwendet.
            \begin{solution}
                   \begin{lstlisting}
do {
    neo.move();
} while(!neo.isOnPhoneBooth());
                   \end{lstlisting}

                \end{solution}

            \part Dieses Mal haben die Agenten alle Telefonzellen in Neos Nähe zerstört. Welche Auswirkung hat das auf deinen Code aus \textit{(b)}? Nutze die Operation \texttt{Neo.canMove()}, um den Fehler zu beheben.

            \textbf{Für diese Aufgabe} müsst ihr \texttt{this.boothsDestroyed} auf \texttt{true} setzen.
                \begin{solution}
                    \begin{lstlisting}
while(neo.canMove()) {
    neo.move();
}
                    \end{lstlisting}
                \end{solution}
        \end{parts}

    \renewcommand{\workingtimeMinutes}{30}
    \titledquestion{Anwendung von Schleifen und If-Anweisungen}
        \begin{parts}
            \part Morpheus musste untertauchen. Aber damit Neo ihn finden kann, hat er einen Pfad aus Pillen gelegt. Immer wenn Neo auf einem Feld steht, auf dem eine rote Pille liegt, muss er nach rechts abbiegen.

            \textbf{Extra für diese Aufgabe} stellen wir eine spezielle Operation \texttt{Neo.peakPill()} zur Verfügung, die die Pille zurück gibt, die auf dem selben Feld liegt, auf dem Neo gerade steht. Die Operation gibt null zurück, wenn Neo auf einem Feld steht, auf dem es keine Pille gibt.

            Außerdem kann man die Pille mit der Query \texttt{getColor()} fragen, welche Farbe sie hat.
            Die Query gibt \texttt{Color.RED} zurück, wenn die Pille rot ist und \texttt{Color.BLUE}, wenn die Pille blau ist.

            Neo muss solange suchen, bis er auf eine Telefonzelle trifft.
                \begin{solution}
                   \begin{lstlisting}
public final void solve() {
    while(!this.neo.isOnPhoneBooth()) {
    Pill p = this.neo.peakPill();
    if(p != null && p.getColor() == Color.RED) {
        this.neo.collectPill();
        this.neo.turnClockWise();
    }
    this.neo.move();
    }
}
                   \end{lstlisting}

                \end{solution}

            \part Die Agenten sind Morpheus auf der Spur. Er muss den Weg komplizierter machen. Zusätzlich zu den roten Pillen gibt es jetzt auch blaue Pillen. Wenn man auf einem Feld steht, das eine blaue Pille enthält, muss Neo nach links abbiegen.

            \textbf{Diese Aufgabe} enthält wieder die Operation \texttt{Neo.peakPill()}. Außerdem bauen wir das Level so, dass es kein Feld gibt, auf dem sowohl eine blaue, als auch eine rote Pille liegt.
            \begin{solution}
                   \begin{lstlisting}
public void solve() {
    while(!this.neo.isOnPhoneBooth()) {
        Pill p = this.neo.peakPill();
        if(p != null && p.getColor() == Color.RED) {
            this.neo.collectPill();
            this.neo.turnClockWise();
        } else if(p != null) {
            this.neo.collectPill();
            this.neo.turnClockWise();
            this.neo.turnClockWise();
            this.neo.turnClockWise();
        }
        this.neo.move();
    }
}
                   \end{lstlisting}
            \end{solution}
        \end{parts}

    \renewcommand{\workingtimeMinutes}{30}
    \titledquestion{Collections}
        \begin{parts}
            \part Laufe das Feld in einer Reihe ab und sammel die Pillen auf den Feldern ein. Dann laufe wieder zurück und lasse Neo das Feld falsch herrum wieder hinlegen.
            \begin{solution}
                   \begin{lstlisting}
public void solve() {
    Queue<Pill> queue = new LinkedList<Pill>();

    while(this.neo.canMove()) {
        this.neo.move();
        Pill p = this.neo.peakPill();
        if(p!= null) {
            this.neo.collectPill();
            queue.offer(p);
        }
        else {
            queue.offer(null);
        }
    }

    this.neo.turnClockWise();
    this.neo.turnClockWise();

    while(!queue.isEmpty()) {
        Pill p = queue.poll();
        if(p != null) {
            this.neo.drop(p);
        }
        this.neo.move();
    }
}
                   \end{lstlisting}

                \end{solution}

                \part \textbf{(Bonus)} Wie (b) nur in 2D

                \textbf{Für diese Aufgabe} gibt es keine Überprüfung durch den Simulator.
                \begin{solution}
                   \begin{lstlisting}
                    Hier die Lösung eintragen
                   \end{lstlisting}

                \end{solution}
        \end{parts}
\end{questions}

